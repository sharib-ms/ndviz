<html>
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.34/browser.min.js"></script>
    <script src="templates/static/ndv/js/react-with-addons.js"></script>
    <script src="templates/static/ndv/js/react-dom.js"></script>

    <script src="templates/static/ndv/js/threejs/three.js"></script>

  </head>
  <body>
    <script type="text/babel">
    class Visualizer extends React.Component {
      constructor(props) {
        super(props);

        let self = this;

        this.init = this.init.bind(this);
        this.animate = this.animate.bind(this);
        self.renderScene = this.renderScene.bind(this);
        this.triggerRender = this.triggerRender.bind(this);
        this.onWindowResize = this.onWindowResize.bind(this);
        this.onDocumentMouseMove = this.onDocumentMouseMove.bind(this);
        this.onDocumentMouseDown = this.onDocumentMouseDown.bind(this);
        this.onDocumentMouseUp = this.onDocumentMouseUp.bind(this);

        this.onDocumentScroll = this.onDocumentScroll.bind(this);

        this.loadTile = this.loadTile.bind(this);
        self.buildTileUrl = this.buildTileUrl.bind(this);
        //this.updateCameraState = this.updateCameraState.bind(this);

        this.cameraDistance = this.props.cameraDistance || 1000;

        this.onReady = this.props.onReady || (() => {});
        this.onReady(self);
      }

      componentDidMount() {
        let self = this;

        addEventListener('resize', self.onWindowResize,
        false);

        // pan listeners
        addEventListener('mousedown', self.onDocumentMouseDown, false);
        addEventListener('mouseup', self.onDocumentMouseUp, false);
        // zoom listeners
        addEventListener('wheel', self.onDocumentScroll, false);
      }

      init() {
        let self = this;

        self.lastMouse = new THREE.Vector2();
        self.currentRes = 3
        self.zIndex = 1;
        self.url = 'http://synaptomes.neurodata.io/nd/catmaid/collman15v2/EM2k/xy/{z}/{y}_{x}_{res}.png';

        self.offset = new THREE.Vector3();

        self.tiles = {};

        // Set up scene primitives
        self.scene = new THREE.Scene();
        window.scene = self.scene;
        self.renderer = new THREE.WebGLRenderer();
        self.renderer.setPixelRatio(window.devicePixelRatio);
        self.renderer.setSize(window.innerWidth, window.innerHeight);

        // Insert into document
        self.container = document.getElementById('visualizer-target');
        self.container.appendChild(self.renderer.domElement);

        self.camera = new THREE.OrthographicCamera(
          window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2,
          1, 1024.0);
        self.camera.position.z = 400;

        ///xy/{{ starttime }}/{zindex}/{y}_{x}_{z}.png
        /*
        this.loadTile('http://synaptomes.neurodata.io/nd/catmaid/collman15v2/EM2k/xy/1/0_0_3.png', [0,0]);
        this.loadTile('http://synaptomes.neurodata.io/nd/catmaid/collman15v2/EM2k/xy/1/0_1_3.png', [0,1]);
        this.loadTile('http://synaptomes.neurodata.io/nd/catmaid/collman15v2/EM2k/xy/1/1_0_3.png', [1,0]);
        this.loadTile('http://synaptomes.neurodata.io/nd/catmaid/collman15v2/EM2k/xy/1/1_1_3.png', [2,1]);
        */
        this.loadTile(0, 0);
        this.loadTile(0, 1);
        this.loadTile(1, 0);
        this.loadTile(1, 2);
      }

      buildTileUrl(x, y, z, res, url) {
        url = url.replace('{x}', x);
        url = url.replace('{y}', y);
        url = url.replace('{z}', z);
        url = url.replace('{res}', res);
        console.log(url);
        return url;
      }

      loadTile(x, y) {
        let self = this;

        var geometry = new THREE.PlaneGeometry(512, 512);
        var loader = new THREE.TextureLoader();
        loader.load(
          // resource URL
          self.buildTileUrl(x, y, self.zIndex, self.currentRes, self.url),
          // Function when resource is loaded
          function( texture ) {
            var material = new THREE.MeshBasicMaterial({map:texture});
            var mesh = new THREE.Mesh( geometry, material );

            // TODO -- 512 to tilesize, 256 to tilesize / 2
            var pos = new THREE.Vector3(
              (-(window.innerWidth) / 2) + x*512 + 256,
              (window.innerHeight / 2) - y*512 - 256,
              0
            );

            mesh.position.copy(pos);
            self.scene.add( mesh );
            self.tiles[x + ',' + y] = mesh;
            self.renderScene();
          },
          // Function to be called when download progresses
          function( xhr ) {
            // null
          },
          // Function called when download errors
          function( xhr ) {
            console.log('error');
          }
        );
      }

      onWindowResize() {
        let self = this;

        self.camera.aspect = window.innerWidth / window.innerHeight;
        self.camera.updateProjectionMatrix();

        self.renderer.setSize( window.innerWidth, window.innerHeight );
      }

      onDocumentMouseDown(event) {
        let self = this;

        event.preventDefault();

        self.lastMouse.set(
          (event.clientX / window.innerWidth) * 2 - 1,
          -(event.clientY / window.innerHeight) * 2 + 1
        );

        self.container.style.cursor = 'move';

        addEventListener('mousemove', self.onDocumentMouseMove, false);
      }

      onDocumentMouseUp(event) {
        let self = this;

        self.container.style.cursor = 'auto';

        removeEventListener('mousemove', self.onDocumentMouseMove);
      }

      onDocumentMouseMove(event) {
        let self = this;

        event.preventDefault();

        var mouse = new THREE.Vector2(
          (event.clientX / window.innerWidth) * 2 - 1,
          -(event.clientY / window.innerHeight) * 2 + 1
        );

        // convoluted subtraction
        var mouseDiff = new THREE.Vector3(
          mouse.x - self.lastMouse.x,
          mouse.y - self.lastMouse.y,
        1);
        mouseDiff.unproject(self.camera);
        // unprojecting affects the z coordinate, but we don't care
        mouseDiff.z = 0;

        self.lastMouse = mouse;

        for (var meshpt in self.tiles) {
          var mesh = self.tiles[meshpt];
          mesh.position.add( mouseDiff );
        }

        self.renderScene();
      }

      onDocumentScroll(event) {
        console.log(event.deltaY);
        // convert to zoom factor
      }

      animate() {
        let self = this;
        requestAnimationFrame(self.animate);

        self.renderer.render(self.scene, self.camera);

      }

      renderScene() {
        let self = this;
        console.log(self.tiles);
        self.renderer.render(self.scene, self.camera);
      }

      triggerRender() {
          let self = this;

          self.init();
          self.renderScene();
          //self.animate();
      }

      render() {
        return (
          <div id="visualizer-target"></div>
        );
      }

    };

    var MainLayout = React.createClass({
      componentDidMount: function() {
        this.refs.mainVisualizer.triggerRender();
      },
      render: function() {
        return (
          <div>
            <Visualizer
              ref="mainVisualizer"
            />
          </div>
        );
      }
    });

    ReactDOM.render(
        <MainLayout />,
        document.getElementById('react-target')
    );

  </script>
  <div id="react-target"></div>
  </body>
</html>
